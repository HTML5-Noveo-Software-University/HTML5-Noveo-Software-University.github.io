extends ../base/base-lect.pug

block layout-settings
    include ../lectures/themes/git.pug
    - var conf = git;
    - var pageTitle = conf.title;
    - var pageType = 'lecture'
    - var currentPage = conf.page;
    - var subthemes = conf.subthemes;
    -
        var listToRead = [];
    -
        var listVCSFeatures = [
            'возвращать отдельные файлы к прежнему виду;',
            'возвращать к прежнему состоянию весь проект;',
            'просматривать происходящие со временем изменения;',
            'определять, кто последним вносил изменения во внезапно переставший работать модуль, кто и когда внёс в код какую-то ошибку, и многое другое.'
        ];
    -
        var listVCSTypes = [
            'локальные - все изменения файлов хранятся в базе данных на локальном компьютере. Проблема: данные легко потерять, если сломается локальный компьютер.',
            'централизованные - в таких системах есть центральный сервер, на котором хранятся все файлы под версионным контролем, и ряд клиентов, которые получают копии файлов из него. Проблема: данные легко потерять, если сломается сервер.',
            'распределенные (Git, Mercurial, Bazaar) - клиенты не просто выгружают последние версии файлов, а полностью копируют весь репозиторий. Поэтому в случае, когда "умирает" сервер, через который шла работа, любой клиентский репозиторий может быть скопирован обратно на сервер, чтобы восстановить базу данных. Каждый раз, когда клиент забирает свежую версию файлов, он создаёт себе полную копию всех данных.'
        ];
    -
        var listGitFeatures = [
            'слепки вместо патчей.',
            'почти все операции - локальные. Плюсы: быстрота, возможность работать без интернета (сохранил изменения локально, а затем отправил их на сервер, когда появилась сеть).',
            'чаще всего данные в Git только добавляются. Очень сложно заставить систему удалить данные или сделать что-то неотменяемое. Можно, как и в любой другой СКВ, потерять данные, которые вы ещё не сохранили, но как только они зафиксированы, их очень сложно потерять, особенно если вы регулярно отправляете изменения в другой репозиторий.'
        ];
    -
        var listGitInitRepo = [
            'импорт в Git уже существующего проекта;',
            'клонирование существующего репозитория с сервера.'
        ];
    -
        var listFilesStage = [
            'под версионным контролем (отслеживаемые, tracked);',
            'не под версионным контролем (неотслеживаемые, untracked).'
        ];
    -
        var listFilesTracked = [
            'неизменёнными (unmodified);',
            'изменёнными (modified)',
            'подготовленными к коммиту (staged)'
        ];
    -
        var listBadCommitExamples = [
            'Commit 159;',
            '2017-01-13 23:59;',
            '(╯°□°)╯︵ ┻━┻'
        ];
    -
        var listGoodCommitExamples = [
            'Add base styles;',
            'Fix login form;',
            'Refactor main page grid.'
        ];
    -
        var listGitIgnoreExamples = [
            'макеты;',
            'сторонние библиотеки;',
            'сбилденные файлы (для production).'
        ];
    -
        var listGitBranchesWorkflow = [
            'Ветка master - стабильный код (готовый для production).',
            'Ветка develop - для разработки и тестирования (может не быть стабильной постоянно), в стабильные моменты вливается в master.',
            'Тематические ветки для конкретных задач, например, issue54, fix_bug_in_footer - после завершения работы эти ветки вливаются в develop и удаляются командой git branch -d имя_ветки.'
        ];
    -
        var listGitLabRegistration = [
            'Зарегистрироваться на https://gitlab.school.noveogroup.com/',
            'Создать новый проект под названием username-HTML2017: https://gitlab.school.noveogroup.com/projects/new',
            'Отредактировать файл readme.md',
            'Добавить проект в группу HTML'
        ];
    -
        var listTestTask = [
            'Склонировать свой проект.',
            'Создать ветку test-task.',
            'Изменить файл readme.',
            'Запушить изменения в ветку test-task'
        ];
    -
      var listToRead = [{
          id: "",
          title: "Книга по Git",
          href: "https://git-scm.com/book/ru/v1/"
      }, {
          id: "",
          title: "Шпаргалка по Git",
          href: "https://education.github.com/git-cheat-sheet-education.pdf"
      }, {
          id: "",
          title: "Как писать сообщения коммитов",
          href: "http://frontiermag.ru/commit-message.html"
      }, {
          id: "",
          title: "Подход к разработке с ипользованием Git (пример GitHub)",
          href: "https://guides.github.com/introduction/flow/"
      }, {
          id: "",
          title: "Git для Windows",
          href: "https://git-for-windows.github.io/"
      }];

block main
    include ../base/mixins/mixin-slides.pug
    main.main
        .slides-wrap
            +main-slide(pageTitle, 'Дмитрий Мещеряков')

            .slide(id=subthemes.intro.href)
                h2.h2.-subtheme-h Системы контроля версий
                +p().
                    Система контроля версий (СКВ) — это система, регистрирующая изменения в одном или нескольких файлах с тем, чтобы в дальнейшем была возможность вернуться к определённым старым версиям этих файлов.
                +list('СКВ дает возможность:', listVCSFeatures)
                +listCap('Виды СКВ:', listVCSTypes)

            .slide
                h2.h2.-subtheme-h Git. Основные особенности
                .-centered
                    .slide__cols
                        .slide__col
                            img(src="/static/images/pages/git/git-logo.png" alt="Git logo")
                        .slide__col
                            +p().
                                На данный момент, фактически, Git - самая распространенная СКВ. Появился в 2005 году, создатели - разработчики Linux (в частности, основатель Linux Линус Торвальдс).
                    +listCap('Основные особенности Git:', listGitFeatures)

            .slide
                h2.h2.-subtheme-h Хранение данных в Git
                .slide__cols
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Главное отличие Git'а от любых других СКВ (например, Subversion и ей подобных) — это то, как Git смотрит на свои данные. В принципе, большинство других систем хранит информацию как список изменений (патчей) для файлов. Эти системы (CVS, Subversion, Perforce, Bazaar и другие) относятся к хранимым данным как к набору файлов и изменений, сделанных для каждого из этих файлов во времени, как показано на рисунке 1.
                        .-visible-on-slide
                            h3.h3 Другие СКВ
                        +figure('Рисунок 1. Другие системы хранят данные как изменения к базовой версии для каждого файла', conf.page, 'data-saving-other.png')
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Git не хранит свои данные в таком виде. Вместо этого Git считает хранимые данные набором слепков небольшой файловой системы. Каждый раз, когда вы фиксируете текущую версию проекта, Git, по сути, сохраняет слепок того, как выглядят все файлы проекта на текущий момент. Ради эффективности, если файл не менялся, Git не сохраняет файл снова, а делает ссылку на ранее сохранённый файл. То, как Git подходит к хранению данных, похоже на рисунок 2.
                        .-visible-on-slide
                            h3.h3 Git
                        +figure('Рисунок 2. Git хранит данные как слепки состояний проекта во времени', conf.page, 'data-saving-git.png')

            .slide
                h2.h2.-subtheme-h Установка и первоначальная настройка Git
                .slide__cols
                    .slide__col
                        +p().
                            Git для Windows:
                            #[a(href="https://git-for-windows.github.io/", target="_blank") https://git-for-windows.github.io/]
                        +p().
                            После установки у вас будет как консольная версия, так и графическая.
                        +p().
                            Консоль можно открыть в любом месте в проводнике : правая кнопка - Git Bash Here
                        +p().
                            Первое, что вам следует сделать после установки Git'а, — указать ваше имя и адрес электронной почты. Это важно, потому что каждый коммит в Git'е содержит эту информацию, и она включена в коммиты, передаваемые вами.
                        +console("C:/", "git config --global user.name \"Name Surname\"")
                        +console("C:/", "git config --global user.email email@example.com")
                        .-hidden-on-slide
                            +p().
                                Если указана опция --global, то эти настройки достаточно сделать только один раз, поскольку в этом случае Git будет использовать эти данные для всего, что вы делаете в этой системе. Если для каких-то отдельных проектов вы хотите указать другое имя или электронную почту, можно выполнить эту же команду без параметра --global в каталоге с нужным проектом.
                    .slide__col
                        +p().
                            Для изменения размера текста нужно щелкнуть правой кнопкой мыши по логотипу Git Bash в верхнем левом углу и выбрать пункт Options:
                        img(src="/static/images/pages/git/git-bash-options.jpg" alt="Окно настроек Git Bash")

            .slide(id=subthemes.basic.href)
                h2.h2.-subtheme-h Создание Git-репозитория
                +p().
                    Репозиторий - это проектная папка, в которой хранятся все документы вместе с историей их изменения и другой служебной информацией.
                +list('2 способа создать репозиторий:', listGitInitRepo)
                .slide__cols
                    .slide__col
                        h3.h3 Импорт в Git уже существующего проекта
                        .-hidden-on-slide
                            +p().
                                Если вы собираетесь начать использовать Git для существующего проекта, то вам необходимо перейти в проектный каталог и в командной строке ввести
                        +console("C:/ProjectFolder", "git init")
                        .-hidden-on-slide
                            +p().
                                Эта команда создаёт в текущем каталоге новый подкаталог с именем .git содержащий все необходимые файлы репозитория — основу Git-репозитория. На этом этапе ваш проект ещё не находится под версионным контролем
                    .slide__col
                        h3.h3 Клонирование существующего репозитория с сервера
                        .-hidden-on-slide
                            +p().
                                Если вы желаете получить копию существующего репозитория Git, например, проекта, в котором вы хотите поучаствовать, то вам нужна команда
                            +bold-no-sematics('git clone [url]')
                        +console("C:/", "git clone https://github.com/jquery/jquery.git")
                        .-hidden-on-slide
                            +p().
                                Эта команда создаёт каталог с именем jquery, инициализирует в нём каталог .git, скачивает все данные для этого репозитория и создаёт (checks out) рабочую копию последней версии. Если вы зайдёте в новый каталог jquery, вы увидите в нём проектные файлы, пригодные для работы и использования.
                +p().
                    В Git'е реализовано несколько транспортных протоколов, которые вы можете использовать. Наиболее используемые: https и ssh

            .slide
                h2.h2.-subtheme-h Состояния файлов
                +remember()
                    | Основной принцип работы с Git: делаем некоторые изменения и фиксируем “снимки” состояния (snapshots или commits) этих изменений в репозитории каждый раз, когда проект достигает состояния, которое хотелось бы сохранить.
                +list('Каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний:', listFilesStage)
                .slide__cols
                    .slide__col
                        +list('Отслеживаемые файлы — это те файлы, которые были в последнем слепке состояния проекта (snapshot); они могут быть:', listFilesTracked)
                    .slide__col
                        +p().
                            Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний слепок состояния и не подготовлены к коммиту.

            .slide
                h2.h2.-subtheme-h.-visible-on-slide Состояния файлов
                .slide__cols
                    .slide__col
                        +p().
                            Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что вы только взяли их из хранилища (checked them out) и ничего пока не редактировали.
                        +hint().
                            Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, т.к. вы изменили их с момента последнего коммита. Вы индексируете (stage) эти изменения и затем фиксируете все индексированные изменения, а затем цикл повторяется. Этот жизненный цикл изображён на рисунке 3.
                    .slide__col
                        +figure('Рисунок 3. Жизненный цикл состояний файлов', conf.page, 'git-file-status-lifecycle.png')

            .slide
                h2.h2.-subtheme-h Отслеживание состояния файлов
                .slide__cols
                    .slide__col
                        +p().
                            Для того чтобы посмотреть текущее состояние рабочего каталога, используется команда
                        +console("C:/Project", "git status")
                    .slide__col
                        +p().
                            После создания файла index.html рабочий каталог выглядит так:
                        img(src="/static/images/pages/git/git-status.jpg" alt="Вывод команды git status")

            .slide
                h2.h2.-subtheme-h Отслеживание новых файлов
                .slide__cols
                    .slide__col
                        +p().
                            Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда
                        +console("C:/Project", "git add Название файла")
                    .slide__col
                        +p().
                            После добавления файла index.html под версионный контроль рабочий каталог выглядит так:
                        img(src="/static/images/pages/git/git-add.jpg" alt="Вывод команды git add")

            .slide
                h2.h2.-subtheme-h Индексация отслеживаемых файлов
                .slide__cols
                    .slide__col
                        +p().
                            Если внести изменения в отслеживаемый файл, то он окажется в секции "Changes not staged for commit" - это означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не проиндексирован. Чтобы проиндексировать его, необходимо также выполнить команду
                        +console("C:/Project", "git add Название файла")
                        h3.h3 Полезные команды
                        +p().
                            Добавить в индекс все измененные, удаленые, неотслеживаемые файлы:
                        +console("C:/Project", "git add .")
                        +p().
                            Добавить в индекс все измененные и удаленые файлы:
                        +console("C:/Project", "git add -u")
                    .slide__col
                        +p().
                            При изменении отслеживаемого файла index.html рабочий каталог выглядит так:
                        img(src="/static/images/pages/git/git-add-index.jpg" alt="Вывод команды git add")
                        +p().
                            После выполнения команды git add index.html:
                        img(src="/static/images/pages/git/git-add-index2.jpg" alt="Вывод команды git add")

            .slide
                h2.h2.-subtheme-h Фиксация изменений
                .slide__cols
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Когда ваш индекс настроен так, как вам и хотелось, вы можете зафиксировать свои изменения. Запомните, всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые вами, и для которых вы не выполнили git add после момента редактирования — не войдут в этот коммит. Они останутся изменёнными файлами на вашем диске.
                        +p().
                            Для фиксации изменений используется команда
                        +console("C:/Project", "git commit")
                        +p().
                            Эта команда откроет текстовый редактор (по умолчанию Vim), в котором нужно будет ввести сообщение коммита.
                        +p().
                            Работать в этом редакторе неудобно, проще вводить сообщение коммита прямо в консоли при помощи команды
                        +console("C:/Project", "git commit -m Название коммита")
                        .-hidden-on-slide
                            +p().
                                Старайтесь давать осмысленные названия коммитам (что конкретно было сделано, например “Верстка хедера” (лучше по-английски в повелительном наклонении “Add header styles”). Сам Гит использует повелительное наклонение (это видно при слиянии веток).
                            +p().
                                Старайтесь делать более мелкие коммиты (атомарные). Это позволит в дальнейшем проще смотреть на историю разработки.
                        .slide__cols
                            .slide__col
                                +listCap('Примеры плохих названий коммитов:', listBadCommitExamples)
                            .slide__col
                                +listCap('Примеры хороших названий коммитов:', listGoodCommitExamples)
                        +p().
                            Можно сразу фиксировать изменения без дополнительной индексации файлов (git add):
                        +console("C:/Project", "git commit -a -m Название коммита")
                    .slide__col
                        +p().
                            После выполнения команды git commit -m "Add index.html":
                        img(src="/static/images/pages/git/git-commit.jpg" alt="Вывод команды git commit")

            .slide
                h2.h2.-subtheme-h Удаление файлов
                .slide__cols
                    .slide__col
                        +p().
                            Для того чтобы удалить файл из Git'а, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса), а затем выполнить коммит. Это позволяет сделать команда git rm, которая также удаляет файл из вашего рабочего каталога, так что вы в следующий раз не увидите его как "неотслеживаемый".
                        +console("C:/Project", "git rm Название файла")
                    .slide__col
                        +p().
                            После выполнения команды git rm index.html:
                        img(src="/static/images/pages/git/git-rm.jpg" alt="Вывод команды git rm")

            .slide
                h2.h2.-subtheme-h Игнорирование файлов
                .slide__cols
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых.
                        +listCap('Файлы, которые должны быть неотслеживаемыми:', listGitIgnoreExamples)
                        +p().
                            Для добавления файлов в список неотслеживаемых в корне проектного каталога создается файл .gitignore с перечислением шаблонов, соответствующих таким файлам.
                    .slide__col
                        +p().
                            Пример файла .gitignore:
                        +code('css').
                            assets
                            node_modules
                            build

            .slide
                h2.h2.-subtheme-h Просмотр изменений
                .slide__cols
                    .slide__col
                        +p().
                            Для детального просмотра изменений используется команда
                        +console("C:/Project", "git diff")
                        +p().
                            Она показывает непосредственно добавленные и удалённые строки в еще непроиндексированных файлах.
                        +p().
                            Для просмотра изменений в проиндексированных файлах используется команда
                        +console("C:/Project", "git diff --staged")
                    .slide__col
                        +p().
                            После выполнения команды git diff:
                        img(src="/static/images/pages/git/git-diff.jpg" alt="Вывод команды git diff")

            .slide
                h2.h2.-subtheme-h Просмотр истории коммитов
                .slide__cols
                    .slide__col
                        +p().
                            Для просмотра истории коммитов используется команда
                        +console("C:/Project", "git log")
                        +p().
                            Для выхода из просмотра нужно нажать Ctrl + C.
                    .slide__col
                        +p().
                            После выполнения команды git log:
                        img(src="/static/images/pages/git/git-log.jpg" alt="Вывод команды git log")

            .slide
                h2.h2.-subtheme-h Отмена изменений
                .slide__cols
                    .slide__col
                        h3.h3 Отмена изменений в файлах
                        +p().
                            Отмена изменений в файле с момента последнего коммита:
                        +console("C:/Project", "git checkout Название файла")
                        +p().
                            Отмена изменений во всех файлах:
                        +console("C:/Project", "git checkout .")
                        +p().
                            Отмена добавления файлов в индекс (отмена команды git add):
                        +console("C:/Project", "git reset HEAD")
                    .slide__col
                        h3.h3 Отмена коммитов
                        +p().
                            Добавление к последнему коммиту новых изменений:
                        +console("C:/Project", "git commit -a --amend")
                        +p().
                            Отмена последнего коммита (изменения в файлах сохранятся):
                        +console("C:/Project", "git reset --soft HEAD^")
                        +p().
                            Удаление коммита (вместе с изменениями в файлах):
                        +console("C:/Project", "git reset --hard HEAD^")

            .slide(id=subthemes.branching.href)
                h2.h2.-subtheme-h= subthemes.branching.title
                .slide__cols
                    .slide__col
                        +p().
                            Ветвление означает, что вы отклоняетесь от основной линии разработки и продолжаете работу, не вмешиваясь в основную линию.
                        .-hidden-on-slide
                            +hint().
                                Некоторые говорят, что модель ветвления Git'а - это его “killer feature“. Способ ветвления в Git'е чрезвычайно легковесен, что делает операции ветвления практически мгновенными и переключение туда-сюда между ветками обычно так же быстрым.
                    .slide__col
                        .-visible-on-slide
                            +hint().
                                Модель ветвления Git'а - это его “killer feature“.
                .-hidden-on-slide
                    +p().
                        Для наглядности давайте предположим, что у вас есть каталог, содержащий три файла, и вы хотите добавить их все в индекс и сделать коммит. При добавлении файлов в индекс для каждого из них вычислится контрольная сумма, затем эти версии файлов будут сохранены в Git-репозиторий (Git обращается к ним как к двоичным данным), а их контрольные суммы добавятся в индекс
                    +console("C:/Project", "git add README test.rb LICENSE")
                    +console("C:/Project", "git commit -m 'initial commit'")
                    +p().
                        Когда вы создаёте коммит, выполняя git commit, Git вычисляет контрольную сумму каждого подкаталога (в нашем случае только корневого каталога) и сохраняет эти объекты-деревья в Git-репозиторий. Затем Git создаёт объект для коммита, в котором есть метаданные и указатель на объект-дерево для корня проекта. Таким образом, Git сможет воссоздать текущее состояние, когда будет нужно.
                    +p().
                        Ваш Git-репозиторий теперь содержит пять объектов: по одному блобу для содержимого каждого из трёх файлов, одно дерево, в котором перечислено содержимое каталога и определено соответствие имён файлов и блобов, и один коммит с указателем на тот самый объект-дерево для корня и со всеми метаданными коммита. Схематично данные в этом Git-репозитории выглядят так, как показано на рисунке 4.
                .slide__cols
                    .slide__col
                        .-visible-on-slide
                            +p().
                                Пример: репозиторий с тремя файлами. Делаем коммит. Схематично данные в этом репозитории выглядят так, как показано на рисунке 4.
                            +console("C:/Project", "git add README test.rb LICENSE")
                            +console("C:/Project", "git commit -m 'initial commit'")
                        +figure('Рисунок 4. Данные репозитория с единственным коммитом', conf.page, 'git-initial-commit.png')
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Если вы сделаете некоторые изменения и создадите новый коммит, то следующий коммит сохранит указатель на коммит, который шёл непосредственно перед ним. После следующих двух коммитов история может выглядеть, как на рисунке 5.
                        .-visible-on-slide
                            +p().
                                После следующих двух коммитов история будет выглядеть так:
                        +figure('Рисунок 5. Данные объектов Git для нескольких коммитов', conf.page, 'git-commit-next.png')

            .slide
                h2.h2.-subtheme-h.-visible-on-slide= subthemes.branching.title
                .slide__cols
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Ветка в Git'е — это просто легковесный подвижный указатель на один из этих коммитов. Ветка по умолчанию в Git'е называется master. Когда вы создаёте коммиты на начальном этапе, вам дана ветка master, указывающая на последний сделанный коммит. При каждом новом коммите она сдвигается вперёд автоматически (рисунок 6).
                        .-visible-on-slide
                            +remember()
                                | Ветка в Git'е — это просто легковесный подвижный указатель на один из коммитов. Ветка по умолчанию в Git'е называется master.
                        +figure('Рисунок 6. Ветка указывает на историю коммитов', conf.page, 'branch.png')
                    .slide__col
                        +p().
                            При создании новой ветки вы создаете новый указатель, который можно будет перемещать.
                            Для создания новой ветки используется команда:
                        +console("C:/Project", "git branch Название ветки")
                        +p().
                            Создадим новую ветку testing:
                        +console("C:/Project", "git branch testing")
                        +p().
                            Эта команда создаст новый указатель на тот самый коммит, на котором вы сейчас находитесь (рисунок 7).
                        +figure('Рисунок 7. Две ветки, указывающие на историю коммитов', conf.page, 'new-branch.png')

            .slide
                h2.h2.-subtheme-h.-visible-on-slide= subthemes.branching.title
                .slide__cols
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Откуда Git узнает, на какой ветке вы находитесь в данный момент? Он хранит специальный указатель, который называется HEAD (верхушка). В данный момент вы всё ещё на ветке master. Команда git branch только создала новую ветку, она не переключила вас на неё (рисунок 8).
                        .-visible-on-slide
                            +remember
                                | HEAD - специальный указатель, указывающий на текущую ветку
                        +figure('Рисунок 8. HEAD указывает на текущую ветку', conf.page, 'branch-head.png')
                    .slide__col
                        +p().
                            Чтобы перейти на существующую ветку, нужно выполнить команду:
                        +console("C:/Project", "git checkout testing")
                        +figure('Рисунок 9. HEAD указывает на другую ветку после переключения веток', conf.page, 'git-checkout.png')
                        +p().
                            Чтобы создать ветку и сразу же перейти на неё, вы можете выполнить команду:
                        +console("C:/Project", "git checkout -b Название ветки")

            .slide
                h2.h2.-subtheme-h.-visible-on-slide= subthemes.branching.title
                .slide__cols
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Если сделать коммит в ветке testing, то ветка testing передвинется вперёд, но ветка master всё ещё будет указывать на коммит, на котором вы были, когда выполняли git checkout, чтобы переключить ветки (рисунок 10).
                        .-visible-on-slide
                            +p().
                                Сделаем коммит в ветке testing (рисунок 10).
                        +figure('Рисунок 10. Ветка, на которую указывает HEAD, движется вперёд с каждым коммитом', conf.page, 'git-checkout2.png').
                    .slide__col
                        +p().
                            Выполним команду
                        +console("C:/Project", "git checkout master")
                        .-hidden-on-slide
                            +p().
                                Эта команда выполнила два действия. Она передвинула указатель HEAD назад на ветку master и вернула файлы в вашем рабочем каталоге назад, в соответствие со снимком состояния, на который указывает master. Это также означает, что изменения, которые вы делаете, начиная с этого момента, будут ответвляться от старой версии проекта. Это, по сути, откатывает изменения, которые вы временно делали на ветке testing, так что дальше вы можете двигаться в другом направлении (рисунок 11).
                        +figure('Рисунок 11. HEAD перемещается на другую ветку при checkout', conf.page, 'git-checkout3.png')

            .slide
                h2.h2.-subtheme-h.-visible-on-slide= subthemes.branching.title
                .slide__cols
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Если теперь сделать коммит в ветке master, то история проекта разветвится (рисунок 12). Вы создали новую ветку, перешли на неё, поработали на ней немного, переключились обратно на основную ветку и выполнили другую работу. Оба эти изменения изолированы в отдельных ветках: вы можете переключаться туда и обратно между ветками и слить их, когда будете готовы.
                        .-visible-on-slide
                            +p().
                                Сделаем коммит в ветке master (рисунок 12).
                        +figure('Рисунок 12. История с разошедшимися ветками', conf.page, 'git-checkout4.png')
                        +hint().
                            Из-за того, что ветка в Git'е на самом деле является простым файлом, который содержит 40 символов контрольной суммы SHA-1 коммита, на который он указывает, создание и удаление веток практически беззатратно и мгновенно.
                    .slide__col
                        +p().
                            Для просмотра всех веток в репозитории используется команда
                        +console("C:/Project", "git branch")
                        img(src="/static/images/pages/git/git-branch.jpg" alt="Результат работы команды git branch")
                        +p().
                            Текущая ветка подсвечена и отмечена символом *.

            .slide
                h2.h2.-subtheme-h Слияние веток. Подход к работе с ветками
                .slide__cols
                    .slide__col
                        h3.h3 Слияние веток
                        +p().
                            1 Переключиться в ветку, в которую вы хотите влить изменения:
                        +console("C:/Project", "git checkout master")
                        +p().
                            2 Влить изменения из нужной ветки:
                        +console("C:/Project", "git merge testing")
                    .slide__col
                        +listCap('Подход к работе с ветками:', listGitBranchesWorkflow)

            .slide
                h2.h2.-subtheme-h Конфликты при слиянии веток
                .slide__cols
                    .slide__col
                        +p().
                            Если вы изменили одну и ту же часть файла по-разному в двух ветках, которые собираетесь слить, Git не сможет сделать это чисто.
                        +p().
                            Предположим, в ветке master вы добавили в файл index.html строку I'm Vasya!, а в ветке testing - строку I'm Peter!
                        +p().
                            При попытке выполнить команду git merge testing в ветке master возникнет конфликт слияния:
                        img(src="/static/images/pages/git/merge-conflict.jpg" alt="Конфликт слияния")
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Git не создал новый коммит для слияния. Он приостановил этот процесс до тех пор, пока вы не разрешите конфликт. Если вы хотите посмотреть, какие файлы не прошли слияние (на любом этапе после возникновения конфликта), выполните команду git status.
                        .-visible-on-slide
                            +p().
                                Посмотреть какие файлы не прошли слияние:
                            +console("C:/Project", "git status")
                        img(src="/static/images/pages/git/merge-conflict2.jpg" alt="Конфликт слияния")

            .slide
                h2.h2.-subtheme-h.-visible-on-slide Конфликты при слиянии веток
                .slide__cols
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Всё, что имеет отношение к конфликту слияния и что не было разрешено, отмечено как unmerged. Git добавляет стандартные маркеры к файлам, которые имеют конфликт, так что вы можете открыть их вручную и разрешить эти конфликты. Файл содержит секцию, которая выглядит примерно так:
                        .-visible-on-slide
                            +p().
                                При конфликте слияния файл содержит секцию, которая выглядит так:
                        img(src="/static/images/pages/git/merge-conflict3.jpg" alt="Содержимое файла при конфликте слияния")
                        .-hidden-on-slide
                            +p().
                                В верхней части блока (всё, что выше =======) это версия из HEAD (ветки master, так как именно на неё вы перешли перед выполнением команды merge), всё, что находится в нижней части — версия в testing. Чтобы разрешить конфликт, вы должны либо выбрать одну из этих частей, либо как-то объединить содержимое по своему усмотрению.
                        .-visible-on-slide
                            +p().
                                Всё, что выше ======= - версия в master, что ниже - версия в testing.
                        +p().
                            Выберем вариант из ветки testing:
                        img(src="/static/images/pages/git/merge-conflict4.jpg" alt="Разрешение конфликта слияния")
                    .slide__col
                        +p().
                            После разрешения конфликта нужно добавить файл в индекс:
                        +console("C:/Project", "git add index.html")
                        img(src="/static/images/pages/git/merge-conflict5.jpg" alt="Разрешение конфликта слияния")
                        +p().
                            И зафиксировать изменения:
                        +console("C:/Project", "git commit -m 'Merge branch testing'")

            .slide(id=subthemes.remoteRepos.href)
                h2.h2.-subtheme-h= subthemes.remoteRepos.title
                .slide__cols
                    .slide__col
                        +p().
                            Удалённые ветки — это ссылки на состояние веток в ваших удалённых репозиториях. Это локальные ветки, которые нельзя перемещать; они двигаются автоматически всякий раз, когда вы осуществляете связь по сети.
                        +p().
                            Они выглядят как (имя удал. репоз.)/(ветка).
                        +p().
                            По умолчанию Git называет удаленный репозиторий origin.
                    .slide__col
                        .-hidden-on-slide
                            +p().
                                Рассмотрим пример. Скажем, у вас в сети есть свой Git-сервер на git.ourcompany.com. Если вы с него что-то склонируете (git clone), Git автоматически назовёт его origin, заберёт оттуда все данные, создаст указатель на то, на что там указывает ветка master, и назовёт его локально origin/master (но вы не можете его двигать). Git также сделает вам вашу собственную ветку master, которая будет начинаться там же, где и ветка master в origin, так что вам будет с чем работать (рисунок 13).
                        .-visible-on-slide
                            +p().
                                Рассмотрим пример. Склонируем репозиторий с Git-сервера (рисунок 13).
                        +figure('Рисунок 13. Клонирование Git-проекта даёт вам собственную ветку master и origin/master, указывающий на ветку master в origin', conf.page, 'git-remote.png')

            .slide
                h2.h2.-subtheme-h.-visible-on-slide= subthemes.remoteRepos.title
                .slide__cols
                    .slide__col
                        +p().
                            Если вы сделаете что-то в своей локальной ветке master, а тем временем кто-то ещё отправит изменения на git.ourcompany.com и обновит там ветку master, то ваши истории продолжатся по-разному (рисунок 14).
                        +figure('Рисунок 14. При выполнении локальной работы и отправке кем-то изменений на удалённый сервер каждая история продолжается по-разному', conf.page, 'git-remote2.png')
                    .slide__col
                        +p().
                            Для синхронизации вашей работы выполняется команда
                        +console("C:/Project", "git fetch origin")
                        .-hidden-on-slide
                            +p().
                                Эта команда ищет, какому серверу соответствует origin (в нашем случае это git.ourcompany.com); извлекает оттуда все данные, которых у вас ещё нет, и обновляет ваше локальное хранилище данных; сдвигает указатель origin/master на новую позицию (рисунок 15).
                        +figure('Рисунок 15. Команда git fetch обновляет ваши удалённые ссылки', conf.page, 'git-fetch.png')
                        .-hidden-on-slide
                            +p().
                                Команда git fetch origin связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта.
                            +p().
                                Важно отметить, что команда fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы (команда git merge).

            .slide
                h2.h2.-subtheme-h Получение данных и отправка изменений
                .slide__cols
                    .slide__col
                        h3.h3 Получение данных (git pull)
                        .-hidden-on-slide
                            +p().
                                Если у вас есть ветка, настроенная на отслеживание удалённой ветки, то вы можете использовать команду git pull. Она автоматически извлекает и затем сливает данные из удалённой ветки в вашу текущую ветку. Этот способ может для вас оказаться более простым или более удобным. К тому же по умолчанию команда git clone автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали (подразумевается, что на удалённом сервере есть ветка master).
                        +p().
                            Выполнение git pull, как правило, извлекает (fetch) данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.
                        +remember()
                            | git pull = git fetch + git merge
                    .slide__col
                        h3.h3 Отправка изменений на сервер (git push)
                        +console("C:/Project", "git push [удал. сервер] [ветка]")
                        +p().
                            Когда вы хотите поделиться своими наработками, вам необходимо отправить (push) их в главный репозиторий. Чтобы отправить вашу ветку master на сервер origin, вы можете выполнить следующую команду для отправки наработок на сервер:
                        +console("C:/Project", "git push origin master")
                        .-hidden-on-slide
                            +p().
                                Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а затем команду push выполняете вы, то ваш push точно будет отклонён. Вам придётся сначала вытянуть (pull) их изменения и объединить с вашими. Только после этого вам будет позволено выполнить push.
                        +p().
                            Если вы создали новую ветку локально, то при первом пуше на сервер указываем origin и название ветки:
                        +console("C:/Project", "git push origin new-branch")
                        +p().
                            При следующих пушах уже можно просто писать git push (git автоматически связывает локальную и удаленную ветки).

            .slide
                h2.h2.-subtheme-h Процесс работы с Git
                .-centered
                    +p().
                        Находясь на ветке master, получаем все изменения с удаленного сервера:
                    +console("C:/Project", "git pull")
                    +p().
                        Переключаемся на новую ветку для решения конкретной задачи:
                    +console("C:/Project", "git checkout -b 'Название ветки'")
                    +p().
                        Индексируем изменения во всех файлах:
                    +console("C:/Project", "git add .")
                    +p().
                        Фиксируем изменения:
                    +console("C:/Project", "git commit -m 'Название коммита'")
                    +p().
                        Отправляем изменения в удаленный репозиторий:
                    +console("C:/Project", "git push origin 'Название ветки'")

            .slide
                h2.h2.-subtheme-h Регистрация на GitLab
                +listOrd("Порядок регистрации", listGitLabRegistration)
                .slide__cols
                    .slide__col
                        img(src="/static/images/pages/git/gitlab.jpg" alt="Добавление проекта в группу")
                    .slide__col
                        img(src="/static/images/pages/git/gitlab2.jpg" alt="Добавление проекта в группу")

            .slide
                h2.h2.-subtheme-h Генерация SSH-ключа
                +p().
                    SSH позволяет устанавливать защищенное подключение между вашим компьютером и GitLab. Не нужно будет при каждом пулле и пуше вводить логин и пароль.
                h3.h3 Порядок генерации SSH-ключа
                .slide__cols
                    .slide__col
                        +p().
                            Зайти в настройках профиля на вкладку SSH keys
                        .-hidden-on-slide
                            img(src="/static/images/pages/git/ssh.jpg" alt="Генерация SSH-ключа")
                        +p().
                            Ввести в консоли команду:
                        +console("C:/Project", "ssh-keygen -t rsa -C 'your_email'")
                        +p().
                            Вывести SSH-ключ в консоль и скопировать:
                        +console("C:/Project", "cat ~/.ssh/id_rsa.pub | clip")
                        +p().
                            Вставить скопированное значение в поле Key, ввести Title (Work) и нажать Add key.
                    .slide__col
                        .-visible-on-slide
                            img(src="/static/images/pages/git/ssh.jpg" alt="Генерация SSH-ключа")

            .slide
                h2.h2.-subtheme-h Тестовое задание
                +listCap("", listTestTask)

            .slide
                h2.h2.-subtheme-h Полезные ссылки
                +toRead("", listToRead)
